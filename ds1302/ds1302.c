#include <reg52.h>
#include <INTRINS.H> //用到_nop_()必须包含的头文件
#include "typedef.h"
#include "ds1302.h"
#include "delay.h"

//******************************************************************************************************************************
//IO设置
//******************************************************************************************************************************
	//sbit RST=P2^5;  //输入信号引脚，读写数据期间必须为高
	//sbit SCLK=P2^6; //串行时钟，控制数据的输入与输出
	//sbit IO=P2^7;   //双向数据线

	sbit RST=P1^0;  //输入信号引脚，读写数据期间必须为高
	sbit SCLK=P1^1; //串行时钟，控制数据的输入与输出
	sbit IO=P1^2;   //双向数据线

//******************************************************************************************************************************
//申请空间
//******************************************************************************************************************************
	extern uchar time[];
	extern uchar date[];

//******************************************************************************************************************************
//写指令
//******************************************************************************************************************************
uchar Ds1302_Read_Data(uchar cmd)//cmd为命令字
{
	uchar i,tempbit,tempdata;//保存临时时位，tempdata保存临时数据
	RST=0; //启动读写之前低电平
	SCLK=0; //启动读写之前低电平
	RST=1;  //置高电平，准备读写
	for(i=0;i<8;i++)
	{  //注意，该循环开始时SCLK为低电平
		if(cmd&0x01) //数据的发送从最低位开始，这里是提取最低位
			IO=1; 			//如果cmd&0x01为真，说明最低位为1
		else
			IO=0;				//为假说明最低位为0，送最低位上的数据总线
			cmd=cmd>>1;		//右移一位，下一个上升沿送上总线
			SCLK=1;   //产生一次上升沿，在这个上升沿DS1302采样总线上的数据
			_nop_();
			SCLK=0;    //拉低SCLK，为制造下个上升沿做准备
	}
//读出数据，低位开始。下降沿读出
		for(i=0;i<8;i++) 
		{
	/*注意，上一循环的最后有一个下降沿，该下降沿使得DS1302已经送?位数据上总线，所以一开始就直接读 */
			if(IO==1)  //如果总线是高电平，说明DS1302送的数据是1
				tempbit=0x80; //置tempbit的最高位位1，相当于读取了I/O上的数据
			else
				tempbit=0;
				tempdata=tempdata>>1|tempbit;//将获得的位整合进tempdata
				SCLK=1; //拉高电平，为产生下个下降沿做准备
				_nop_();
				SCLK=0;//产生	下降沿,DS1302将下一位数据送上总线。
		}
	RST=0;
	return tempdata;
}

//**********************************************************************************************************************************************************
//写数据
//**********************************************************************************************************************************************************
void Ds1302_Write_Data(uchar cmd, uchar dat)
{
	uchar i;
	RST=0;
	SCLK=0;
	RST=1;
	for(i=0;i<8;i++)
	{
		if(cmd&0x01)
			IO=1;
		else
			IO=0;
			cmd=cmd>>1;
			SCLK=1;
			_nop_();
			SCLK=0;
	}
	for(i=0;i<8;i++)  //写入数据到DS1302,上升沿写入
	{
		if(dat&0x01)
			IO=1;
		else
			IO=0;
			dat=dat>>1;
			SCLK=1;//与前一循环中的最后的低电平结合产生一个上升沿
			_nop_();
			SCLK=0;
	}
	RST=0;
}

//******************************************************************************************************************************
//初始化
//******************************************************************************************************************************
void Ds1302_Init()//对DS1302进行初始化，设置开始时间
{
	Ds1302_Write_Data(0x8e,0x00);//将写保护关闭，允许对DS1302进行写操作
	
	Ds1302_Write_Data(0x80,0x24);//设置秒寄存器的初始值是24秒
	Ds1302_Write_Data(0x82,0x57);//设置分寄存器的初始值是57分
	Ds1302_Write_Data(0x84,0x20);//设置小时寄存器的初始值是18时

	Ds1302_Write_Data(0x86,0x01);//设置日寄存器的初始值是1
	Ds1302_Write_Data(0x88,0x12);//设置月寄存器的初始值是12
	Ds1302_Write_Data(0x8A,0x04);//设置周寄存器的初始值是1
	Ds1302_Write_Data(0x8c,0x15);//设置年寄存器的初始值是15

	Ds1302_Write_Data(0x8e,0x80);//打开写保护，禁止往DS1302写入数据
}

//******************************************************************************************************************************
//读时间
//******************************************************************************************************************************
void Ds1302_Read_Time()
{
	uchar Second,Minute,Hour;
	uchar Year,Month,Date,Week;
	Second=Ds1302_Read_Data(0x81);//将秒寄存器的内容读到Second
	Minute=Ds1302_Read_Data(0x83);//将分寄存器的内容读到Minute
	Hour=Ds1302_Read_Data(0x85);//将小时寄存器的内容读到Hour

	Date=Ds1302_Read_Data(0x87);//将日寄存器的内容读到Date
	Month=Ds1302_Read_Data(0x89);//将月寄存器的内容读到Month
	Week=Ds1302_Read_Data(0x8b);//将周的寄存器的内容读到Week
	Year=Ds1302_Read_Data(0x8d);//将年的寄存器的内容读到Year

	time[6]=(Second>>4)+'0';//将秒的低四位（十位）转为字符
	time[7]=(Second&0x0f)+'0';//将秒的高四位（个位）转为字符
	time[3]=(Minute>>4)+'0';//将分的低四位（十位）转为字符
	time[4]=(Minute&0x0f)+'0';//将分的高四位（个位）转为字符
	time[0]=(Hour>>4)+'0';//小时的十位
	time[1]=(Hour&0x0f)+'0';//小时的个位
	
	date[6]=(Date>>4)+'0';//日期的十位
	date[7]=(Date&0x0f)+'0';//日期的个位
	date[3]=(Month>>4)+'0';//月的十位
	date[4]=(Month&0x0f)+'0';//月的个位
	date[0]=(Year>>4)+'0';//年的十位
	date[1]=(Year&0x0f)+'0';//年的个位

	date[9]=(Week&0x0f)+'0';
}




